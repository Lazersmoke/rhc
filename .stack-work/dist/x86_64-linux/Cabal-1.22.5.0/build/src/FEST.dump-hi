
==================== FINAL INTERFACE ====================
2016-09-10 22:52:05.321602 UTC

interface rhc_CuQgCuWWrTE7AdKLazyzq3:FEST 7103
  interface hash: f7e7f1377fb401d4e1d60813fb5e61c5
  ABI hash: d41a04f214d21bb0de7f168b23b72746
  export-list hash: a2b98597fb0c140033f1f212a638d7fb
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 962af636f8e927040c7daa9c21457292
  sig of: Nothing
  used TH splices: False
  where
exports:
  FEST.indent
  FEST.parenPretty
  FEST.parens
  FEST.prettyLines
  FEST.prettyWords
  FEST.prettytep
  FEST.testCase
  FEST.vpretty
  FEST.Case{FEST.Case}
  FEST.Context{FEST.Context}
  FEST.ContextualAssertation{FEST.ContextualAssertation}
  FEST.Declaration{FEST.ClassDeclaration FEST.DataTypeDeclaration FEST.InstanceDeclaration FEST.TypeSignatureDeclaration FEST.TypeSynonymDeclaration FEST.ValueDeclaration}
  FEST.Expression{FEST.ApplicationExpression FEST.CaseExpression FEST.LambdaExpression FEST.LiteralExpression FEST.TypeAnnotatedExpression FEST.VariableExpression}
  FEST.Literal{FEST.CharLiteral FEST.FracLiteral FEST.IntLiteral FEST.StringLiteral}
  FEST.NameSpace{FEST.Type FEST.TypeCons FEST.Value FEST.ValueCons}
  FEST.Pattern{FEST.BlackHolePattern FEST.ConstructedPattern FEST.LiteralPattern FEST.VarPattern}
  FEST.PatternClause{FEST.PatternClause}
  FEST.Pretty{FEST.pretty}
  FEST.TypeExpression{FEST.ApplicationTypeExpression FEST.VariableTypeExpression}
  FEST.TypeSignature{FEST.TypeSignature}
  FEST.VarName{FEST.VarName}
module dependencies:
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  integer-gmp-1.0.0.0:GHC.Integer.Type 371e90fe753f08ddedf0d2657a9ef5c4
74bca47b1885d5da8e96bb94992f5fe9
  $fEqCase :: GHC.Classes.Eq FEST.Case
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.Case FEST.$fEqCase_$c==2 FEST.$fEqCase_$c/= -}
74bca47b1885d5da8e96bb94992f5fe9
  $fEqCase_$c/= :: FEST.Case -> FEST.Case -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: FEST.Case w1 :: FEST.Case ->
                 case w of ww { FEST.Case ww1 ww2 ->
                 case w1 of ww3 { FEST.Case ww4 ww5 ->
                 FEST.$w$c/= ww1 ww2 ww4 ww5 } }) -}
74bca47b1885d5da8e96bb94992f5fe9
  $fEqCase_$c== ::
    FEST.Expression -> FEST.Expression -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
b7ed2cd8bbc299368d4e67f077b04597
  $fEqCase_$c==1 :: FEST.Pattern -> FEST.Pattern -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
74bca47b1885d5da8e96bb94992f5fe9
  $fEqCase_$c==2 :: FEST.Case -> FEST.Case -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: FEST.Case w1 :: FEST.Case ->
                 case w of ww { FEST.Case ww1 ww2 ->
                 case w1 of ww3 { FEST.Case ww4 ww5 ->
                 FEST.$w$c== ww1 ww2 ww4 ww5 } }) -}
26f5e4b54fa99ca7a57f4aee7bdfba7e
  $fEqContext :: GHC.Classes.Eq FEST.Context
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.Context FEST.$fEqContext_$c== FEST.$fEqContext_$c/= -}
26f5e4b54fa99ca7a57f4aee7bdfba7e
  $fEqContext_$c/= :: FEST.Context -> FEST.Context -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: FEST.Context b :: FEST.Context ->
                 case a of wild { FEST.Context a1 ->
                 case b of wild1 { FEST.Context b1 ->
                 case GHC.Classes.$fEq[]_$c==
                        @ FEST.ContextualAssertation
                        FEST.$fEqContextualAssertation
                        a1
                        b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
26f5e4b54fa99ca7a57f4aee7bdfba7e
  $fEqContext_$c== :: FEST.Context -> FEST.Context -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: FEST.Context ds1 :: FEST.Context ->
                 case ds of wild { FEST.Context a1 ->
                 case ds1 of wild1 { FEST.Context b1 ->
                 GHC.Classes.$fEq[]_$c==
                   @ FEST.ContextualAssertation
                   FEST.$fEqContextualAssertation
                   a1
                   b1 } }) -}
67e6e11757dadf3eaf7800b8c0224c87
  $fEqContextualAssertation ::
    GHC.Classes.Eq FEST.ContextualAssertation
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.ContextualAssertation
                  FEST.$fEqContextualAssertation_$c==
                  FEST.$fEqContextualAssertation_$c/= -}
67e6e11757dadf3eaf7800b8c0224c87
  $fEqContextualAssertation_$c/= ::
    FEST.ContextualAssertation
    -> FEST.ContextualAssertation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SL)L),1*U(1*U(1*U,1*U),1*U)><S(S(SL)L),1*U(1*U(1*U,1*U),1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: FEST.ContextualAssertation
                   b :: FEST.ContextualAssertation ->
                 case FEST.$fEqContextualAssertation_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
67e6e11757dadf3eaf7800b8c0224c87
  $fEqContextualAssertation_$c== ::
    FEST.ContextualAssertation
    -> FEST.ContextualAssertation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SL)L),1*U(1*U(1*U,1*U),1*U)><S(S(SL)L),1*U(1*U(1*U,1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: FEST.ContextualAssertation
                   w1 :: FEST.ContextualAssertation ->
                 case w of ww { FEST.ContextualAssertation ww1 ww2 ->
                 case ww1 of ww3 { FEST.VarName ww4 ww5 ->
                 case w1 of ww6 { FEST.ContextualAssertation ww7 ww8 ->
                 case ww7 of ww9 { FEST.VarName ww10 ww11 ->
                 FEST.$w$c==1 ww4 ww5 ww2 ww10 ww11 ww8 } } } }) -}
8dd4ff25e2dfbe4b107d5a6803b228dd
  $fEqDeclaration :: GHC.Classes.Eq FEST.Declaration
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.Declaration
                  FEST.$fEqDeclaration_$c==
                  FEST.$fEqDeclaration_$c/= -}
8dd4ff25e2dfbe4b107d5a6803b228dd
  $fEqDeclaration_$c/= ::
    FEST.Declaration -> FEST.Declaration -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: FEST.Declaration b :: FEST.Declaration ->
                 case FEST.$fEqDeclaration_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
8dd4ff25e2dfbe4b107d5a6803b228dd
  $fEqDeclaration_$c== ::
    FEST.Declaration -> FEST.Declaration -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
74bca47b1885d5da8e96bb94992f5fe9
  $fEqExpression :: GHC.Classes.Eq FEST.Expression
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.Expression FEST.$fEqCase_$c== FEST.$fEqExpression_$c/= -}
74bca47b1885d5da8e96bb94992f5fe9
  $fEqExpression_$c/= ::
    FEST.Expression -> FEST.Expression -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: FEST.Expression b :: FEST.Expression ->
                 case FEST.$fEqCase_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
d40fbcff0c41141af2a3b3390c55f81b
  $fEqLiteral :: GHC.Classes.Eq FEST.Literal
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.Literal FEST.$fEqLiteral_$c== FEST.$fEqLiteral_$c/= -}
d40fbcff0c41141af2a3b3390c55f81b
  $fEqLiteral_$c/= :: FEST.Literal -> FEST.Literal -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: FEST.Literal b :: FEST.Literal ->
                 case FEST.$fEqLiteral_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
d40fbcff0c41141af2a3b3390c55f81b
  $fEqLiteral_$c== :: FEST.Literal -> FEST.Literal -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: FEST.Literal ds1 :: FEST.Literal ->
                 case ds of wild {
                   FEST.StringLiteral a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        FEST.StringLiteral b1 -> GHC.Base.eqString a1 b1 }
                   FEST.CharLiteral a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        FEST.CharLiteral b1 -> GHC.Classes.$fEqChar_$c== a1 b1 }
                   FEST.IntLiteral a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        FEST.IntLiteral b1 -> GHC.Integer.Type.eqInteger a1 b1 }
                   FEST.FracLiteral a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        FEST.FracLiteral b1 -> GHC.Classes.$fEqDouble_$c== a1 b1 } }) -}
96976895518626ffceefcc1709859e83
  $fEqNameSpace :: GHC.Classes.Eq FEST.NameSpace
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.NameSpace FEST.$fEqNameSpace_$c== FEST.$fEqNameSpace_$c/= -}
96976895518626ffceefcc1709859e83
  $fEqNameSpace_$c/= ::
    FEST.NameSpace -> FEST.NameSpace -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: FEST.NameSpace b :: FEST.NameSpace ->
                 case a of wild {
                   FEST.TypeCons
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True FEST.TypeCons -> GHC.Types.False }
                   FEST.ValueCons
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True FEST.ValueCons -> GHC.Types.False }
                   FEST.Value
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True FEST.Value -> GHC.Types.False }
                   FEST.Type
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True FEST.Type -> GHC.Types.False } }) -}
96976895518626ffceefcc1709859e83
  $fEqNameSpace_$c== ::
    FEST.NameSpace -> FEST.NameSpace -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: FEST.NameSpace ds1 :: FEST.NameSpace ->
                 case ds of wild {
                   FEST.TypeCons
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False FEST.TypeCons -> GHC.Types.True }
                   FEST.ValueCons
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False FEST.ValueCons -> GHC.Types.True }
                   FEST.Value
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False FEST.Value -> GHC.Types.True }
                   FEST.Type
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False FEST.Type -> GHC.Types.True } }) -}
b7ed2cd8bbc299368d4e67f077b04597
  $fEqPattern :: GHC.Classes.Eq FEST.Pattern
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.Pattern FEST.$fEqCase_$c==1 FEST.$fEqPattern_$c/= -}
290ab21523d92548e27130f56872ceff
  $fEqPatternClause :: GHC.Classes.Eq FEST.PatternClause
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.PatternClause
                  FEST.$fEqPatternClause_$c==
                  FEST.$fEqPatternClause_$c/= -}
290ab21523d92548e27130f56872ceff
  $fEqPatternClause_$c/= ::
    FEST.PatternClause -> FEST.PatternClause -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SL)LL),1*U(1*U(1*U,1*U),1*U,1*U)><S(S(SL)LL),1*U(1*U(1*U,1*U),1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: FEST.PatternClause b :: FEST.PatternClause ->
                 case FEST.$fEqPatternClause_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
290ab21523d92548e27130f56872ceff
  $fEqPatternClause_$c== ::
    FEST.PatternClause -> FEST.PatternClause -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SL)LL),1*U(1*U(1*U,1*U),1*U,1*U)><S(S(SL)LL),1*U(1*U(1*U,1*U),1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: FEST.PatternClause w1 :: FEST.PatternClause ->
                 case w of ww { FEST.PatternClause ww1 ww2 ww3 ->
                 case ww1 of ww4 { FEST.VarName ww5 ww6 ->
                 case w1 of ww7 { FEST.PatternClause ww8 ww9 ww10 ->
                 case ww8 of ww11 { FEST.VarName ww12 ww13 ->
                 FEST.$w$c==3 ww5 ww6 ww2 ww3 ww12 ww13 ww9 ww10 } } } }) -}
b7ed2cd8bbc299368d4e67f077b04597
  $fEqPattern_$c/= :: FEST.Pattern -> FEST.Pattern -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: FEST.Pattern b :: FEST.Pattern ->
                 case FEST.$fEqCase_$c==1 a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
45b1f5883cb2d7385b6a64406417599d
  $fEqTypeExpression :: GHC.Classes.Eq FEST.TypeExpression
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.TypeExpression
                  FEST.$fEqTypeExpression_$c==
                  FEST.$fEqTypeExpression_$c/= -}
45b1f5883cb2d7385b6a64406417599d
  $fEqTypeExpression_$c/= ::
    FEST.TypeExpression -> FEST.TypeExpression -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: FEST.TypeExpression b :: FEST.TypeExpression ->
                 case FEST.$fEqTypeExpression_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
45b1f5883cb2d7385b6a64406417599d
  $fEqTypeExpression_$c== ::
    FEST.TypeExpression -> FEST.TypeExpression -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
a8fd9c0aacb3ce35339ab402888eb354
  $fEqTypeSignature :: GHC.Classes.Eq FEST.TypeSignature
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.TypeSignature
                  FEST.$fEqTypeSignature_$c==
                  FEST.$fEqTypeSignature_$c/= -}
a8fd9c0aacb3ce35339ab402888eb354
  $fEqTypeSignature_$c/= ::
    FEST.TypeSignature -> FEST.TypeSignature -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(1*U),1*U)><S(S(S)L),1*U(1*U(1*U),1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: FEST.TypeSignature b :: FEST.TypeSignature ->
                 case FEST.$fEqTypeSignature_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
a8fd9c0aacb3ce35339ab402888eb354
  $fEqTypeSignature_$c== ::
    FEST.TypeSignature -> FEST.TypeSignature -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(1*U),1*U)><S(S(S)L),1*U(1*U(1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: FEST.TypeSignature w1 :: FEST.TypeSignature ->
                 case w of ww { FEST.TypeSignature ww1 ww2 ->
                 case ww1 of ww3 { FEST.Context ww4 ->
                 case w1 of ww5 { FEST.TypeSignature ww6 ww7 ->
                 case ww6 of ww8 { FEST.Context ww9 ->
                 FEST.$w$c==4 ww4 ww2 ww9 ww7 } } } }) -}
ec0e04f3757b9b2248122cc5aca779ad
  $fEqVarName :: GHC.Classes.Eq FEST.VarName
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.VarName FEST.$fEqVarName_$c== FEST.$fEqVarName_$c/= -}
ec0e04f3757b9b2248122cc5aca779ad
  $fEqVarName_$c/= :: FEST.VarName -> FEST.VarName -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: FEST.VarName b :: FEST.VarName ->
                 case FEST.$fEqVarName_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
ec0e04f3757b9b2248122cc5aca779ad
  $fEqVarName_$c== :: FEST.VarName -> FEST.VarName -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: FEST.VarName w1 :: FEST.VarName ->
                 case w of ww { FEST.VarName ww1 ww2 ->
                 case w1 of ww3 { FEST.VarName ww4 ww5 ->
                 FEST.$w$c==2 ww1 ww2 ww4 ww5 } }) -}
0abe3bf62c34c8e690d5609e1361738c
  $fPrettyCase :: FEST.Pretty FEST.Case
  DFunId[0]
  {- Arity: 1, Strictness: <S(SL),1*U(1*U,1*U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                FEST.$fPrettyCase_$cpretty
                  `cast`
                (Sym (FEST.NTCo:Pretty[0] <FEST.Case>_N)) -}
0c59738b2041bc5b2b42816424d05f95
  $fPrettyCase_$cpretty :: FEST.Case -> GHC.Base.String
  {- Arity: 1, Strictness: <S(SL),1*U(1*U,1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: FEST.Case ->
                 case w of ww { FEST.Case ww1 ww2 -> FEST.$w$cpretty ww1 ww2 }) -}
c43706d6ae56a8f4f4fbd2bae4e12959
  $fPrettyCase_$cpretty1 :: FEST.Expression -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
06433feda19e0e87146104b5240aab47
  $fPrettyCase_$cpretty2 :: FEST.Pattern -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
0abe3bf62c34c8e690d5609e1361738c
  $fPrettyContext :: FEST.Pretty FEST.Context
  DFunId[0]
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                FEST.$fPrettyContext_$cpretty
                  `cast`
                (Sym (FEST.NTCo:Pretty[0] <FEST.Context>_N)) -}
c8ac9f1dcba5ae108bc82f669091818a
  $fPrettyContext1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " => "#) -}
64f2b974cc78099f24195ce598263494
  $fPrettyContext2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ")"#) -}
3f1d1e49ff717abd984c9ac6990c7d9f
  $fPrettyContext3 :: [FEST.ContextualAssertation] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ x :: [FEST.ContextualAssertation] ->
                 case GHC.Base.map
                        @ FEST.ContextualAssertation
                        @ [GHC.Types.Char]
                        FEST.$fPrettyContext_$cpretty1
                        x of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : x1 xs1
                   -> Data.OldList.intercalate_$spoly_go
                        @ GHC.Types.Char
                        x1
                        (Data.OldList.prependToAll
                           @ [GHC.Types.Char]
                           FEST.$fPrettyContext4
                           xs1) }) -}
faa219d5c30907323e853ff11e16a6b8
  $fPrettyContext4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
6f566d18cc2ee058eef3e8d9c62d9a28
  $fPrettyContext_$cpretty :: FEST.Context -> GHC.Base.String
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: FEST.Context ->
                 case w of ww { FEST.Context ww1 -> FEST.$w$cpretty1 ww1 }) -}
8110bb14ad031d4164716bea51fda777
  $fPrettyContext_$cpretty1 ::
    FEST.ContextualAssertation -> GHC.Base.String
  {- Arity: 1, Strictness: <S(S(LS)L),1*U(1*U(A,1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: FEST.ContextualAssertation ->
                 case w of ww { FEST.ContextualAssertation ww1 ww2 ->
                 case ww1 of ww3 { FEST.VarName ww4 ww5 ->
                 FEST.$w$cpretty2 ww5 ww2 } }) -}
52976eb9f59c01d00640cab98e24f5c2
  $fPrettyContext_go :: [FEST.TypeExpression] -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U> -}
0abe3bf62c34c8e690d5609e1361738c
  $fPrettyContextualAssertation ::
    FEST.Pretty FEST.ContextualAssertation
  DFunId[0]
  {- Arity: 1, Strictness: <S(S(LS)L),1*U(1*U(A,1*U),1*U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                FEST.$fPrettyContext_$cpretty1
                  `cast`
                (Sym (FEST.NTCo:Pretty[0] <FEST.ContextualAssertation>_N)) -}
0abe3bf62c34c8e690d5609e1361738c
  $fPrettyDeclaration :: FEST.Pretty FEST.Declaration
  DFunId[0]
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                FEST.$fPrettyDeclaration_$cpretty
                  `cast`
                (Sym (FEST.NTCo:Pretty[0] <FEST.Declaration>_N)) -}
79f3d2500584908c64b224435cfd5b1d
  $fPrettyDeclaration_$cpretty :: FEST.Declaration -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
0abe3bf62c34c8e690d5609e1361738c
  $fPrettyDouble :: FEST.Pretty GHC.Types.Double
  DFunId[0]
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                FEST.$fPrettyDouble_$cpretty
                  `cast`
                (Sym (FEST.NTCo:Pretty[0] <GHC.Types.Double>_N)) -}
d3ae1003426b69f3604a0ef889823b1f
  $fPrettyDouble_$cpretty :: GHC.Types.Double -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Float.$fShowDouble_$cshow -}
0abe3bf62c34c8e690d5609e1361738c
  $fPrettyExpression :: FEST.Pretty FEST.Expression
  DFunId[0]
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                FEST.$fPrettyCase_$cpretty1
                  `cast`
                (Sym (FEST.NTCo:Pretty[0] <FEST.Expression>_N)) -}
0abe3bf62c34c8e690d5609e1361738c
  $fPrettyInteger :: FEST.Pretty GHC.Integer.Type.Integer
  DFunId[0]
  {- Arity: 1, Strictness: <S,U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                FEST.$fPrettyInteger_$cpretty
                  `cast`
                (Sym (FEST.NTCo:Pretty[0] <GHC.Integer.Type.Integer>_N)) -}
e0ff87a9e7c5360a0350da8ad2b23bd6
  $fPrettyInteger_$cpretty ::
    GHC.Integer.Type.Integer -> GHC.Base.String
  {- Arity: 1, Strictness: <S,U>m2,
     Unfolding: InlineRule (0, True, True)
                GHC.Show.$fShowInteger_$cshow -}
0abe3bf62c34c8e690d5609e1361738c
  $fPrettyLiteral :: FEST.Pretty FEST.Literal
  DFunId[0]
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                FEST.$fPrettyLiteral_$cpretty
                  `cast`
                (Sym (FEST.NTCo:Pretty[0] <FEST.Literal>_N)) -}
f2fc29508e60354204b964d8bddd633a
  $fPrettyLiteral_$cpretty :: FEST.Literal -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ ds :: FEST.Literal ->
                 case ds of wild {
                   FEST.StringLiteral s -> s
                   FEST.CharLiteral c
                   -> GHC.Types.: @ GHC.Types.Char c (GHC.Types.[] @ GHC.Types.Char)
                   FEST.IntLiteral i -> GHC.Show.$fShowInteger_$cshow i
                   FEST.FracLiteral f -> GHC.Float.$fShowDouble_$cshow f }) -}
0abe3bf62c34c8e690d5609e1361738c
  $fPrettyPattern :: FEST.Pretty FEST.Pattern
  DFunId[0]
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                FEST.$fPrettyCase_$cpretty2
                  `cast`
                (Sym (FEST.NTCo:Pretty[0] <FEST.Pattern>_N)) -}
0abe3bf62c34c8e690d5609e1361738c
  $fPrettyPatternClause :: FEST.Pretty FEST.PatternClause
  DFunId[0]
  {- Arity: 1, Strictness: <S(S(LS)LL),1*U(1*U(A,1*U),1*U,1*U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                FEST.$fPrettyPatternClause_$cpretty
                  `cast`
                (Sym (FEST.NTCo:Pretty[0] <FEST.PatternClause>_N)) -}
759e23361f08ff687acfb08485de9033
  $fPrettyPatternClause_$cpretty ::
    FEST.PatternClause -> GHC.Base.String
  {- Arity: 1, Strictness: <S(S(LS)LL),1*U(1*U(A,1*U),1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: FEST.PatternClause ->
                 case w of ww { FEST.PatternClause ww1 ww2 ww3 ->
                 case ww1 of ww4 { FEST.VarName ww5 ww6 ->
                 FEST.$w$cpretty3 ww6 ww2 ww3 } }) -}
ae18cc0e9e1d54952b5c3ca936adfcd4
  $fPrettyPatternClause_go :: [FEST.Pattern] -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U> -}
0abe3bf62c34c8e690d5609e1361738c
  $fPrettyTypeExpression :: FEST.Pretty FEST.TypeExpression
  DFunId[0]
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                FEST.$fPrettyTypeExpression_$cpretty
                  `cast`
                (Sym (FEST.NTCo:Pretty[0] <FEST.TypeExpression>_N)) -}
063efe7824c6473409979726cf63ec45
  $fPrettyTypeExpression_$cpretty ::
    FEST.TypeExpression -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
0abe3bf62c34c8e690d5609e1361738c
  $fPrettyTypeSignature :: FEST.Pretty FEST.TypeSignature
  DFunId[0]
  {- Arity: 1, Strictness: <S(S(S)L),1*U(1*U(1*U),1*U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                FEST.$fPrettyTypeSignature_$cpretty
                  `cast`
                (Sym (FEST.NTCo:Pretty[0] <FEST.TypeSignature>_N)) -}
a723453530f5e10b073397bf7aa2b6e1
  $fPrettyTypeSignature_$cpretty ::
    FEST.TypeSignature -> GHC.Base.String
  {- Arity: 1, Strictness: <S(S(S)L),1*U(1*U(1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: FEST.TypeSignature ->
                 case w of ww { FEST.TypeSignature ww1 ww2 ->
                 case ww1 of ww3 { FEST.Context ww4 ->
                 FEST.$w$cpretty4 ww4 ww2 } }) -}
0abe3bf62c34c8e690d5609e1361738c
  $fPrettyVarName :: FEST.Pretty FEST.VarName
  DFunId[0]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                FEST.$fPrettyVarName_$cpretty
                  `cast`
                (Sym (FEST.NTCo:Pretty[0] <FEST.VarName>_N)) -}
22f3ca09692af0aa27f4d3d5647784db
  $fPrettyVarName_$cpretty :: FEST.VarName -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: FEST.VarName ->
                 case ds of wild { FEST.VarName n s -> s }) -}
74bca47b1885d5da8e96bb94992f5fe9
  $fShowCase :: GHC.Show.Show FEST.Case
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.Case
                  FEST.$fShowCase_$cshowsPrec1
                  FEST.$fShowCase_$cshow
                  FEST.$fShowCase_$cshowList -}
74bca47b1885d5da8e96bb94992f5fe9
  $fShowCase1 :: FEST.Case -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: FEST.Case ->
                 case w of ww { FEST.Case ww1 ww2 ->
                 FEST.$w$cshowsPrec 0 ww1 ww2 }) -}
c44c04fd62694f7ea410476e4c01ef27
  $fShowCase2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Case "#) -}
503f676ba2f2229f124457882f15def4
  $fShowCase3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11) -}
74bca47b1885d5da8e96bb94992f5fe9
  $fShowCase_$cshow :: FEST.Case -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: FEST.Case ->
                 FEST.$fShowCase_$cshowsPrec1
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
74bca47b1885d5da8e96bb94992f5fe9
  $fShowCase_$cshowList :: [FEST.Case] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ FEST.Case FEST.$fShowCase1) -}
b7ed2cd8bbc299368d4e67f077b04597
  $fShowCase_$cshowsPrec ::
    GHC.Types.Int -> FEST.Pattern -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,1*U(U)><S,1*U> -}
74bca47b1885d5da8e96bb94992f5fe9
  $fShowCase_$cshowsPrec1 ::
    GHC.Types.Int -> FEST.Case -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U(1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: FEST.Case ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { FEST.Case ww3 ww4 ->
                 FEST.$w$cshowsPrec ww1 ww3 ww4 } }) -}
26f5e4b54fa99ca7a57f4aee7bdfba7e
  $fShowContext :: GHC.Show.Show FEST.Context
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.Context
                  FEST.$fShowContext_$cshowsPrec
                  FEST.$fShowContext_$cshow
                  FEST.$fShowContext_$cshowList -}
26f5e4b54fa99ca7a57f4aee7bdfba7e
  $fShowContext1 :: FEST.Context -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: FEST.Context w1 :: GHC.Base.String ->
                 case w of ww { FEST.Context ww1 ->
                 FEST.$w$cshowsPrec2 0 ww1 w1 }) -}
1afc1786398c1bf637967a2b22e114fe
  $fShowContext10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Context "#) -}
67e6e11757dadf3eaf7800b8c0224c87
  $fShowContext2 :: FEST.ContextualAssertation -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: FEST.ContextualAssertation
                   w1 :: GHC.Base.String ->
                 case w of ww { FEST.ContextualAssertation ww1 ww2 ->
                 FEST.$w$cshowsPrec3 0 ww1 ww2 w1 }) -}
55f0cade6048985c96f3087318d99176
  $fShowContext3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "ContextualAssertation "#) -}
45b1f5883cb2d7385b6a64406417599d
  $fShowContext4 :: FEST.TypeExpression -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: FEST.TypeExpression w1 :: GHC.Base.String ->
                 FEST.$w$cshowsPrec4 0 w w1) -}
fa5f89292a7b947e427b3aa50aedaa9b
  $fShowContext5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Type"#) -}
c9136fa0a736d61395b112ec0177c752
  $fShowContext6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Value"#) -}
889e568455b1ece0a96d740384583893
  $fShowContext7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ValueCons"#) -}
362db992c74abf684163e642e0806180
  $fShowContext8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TypeCons"#) -}
e3a56499b2e4780f45d1a3a44bc7f450
  $fShowContext9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "VarName "#) -}
26f5e4b54fa99ca7a57f4aee7bdfba7e
  $fShowContext_$cshow :: FEST.Context -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: FEST.Context ->
                 FEST.$fShowContext_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
26f5e4b54fa99ca7a57f4aee7bdfba7e
  $fShowContext_$cshowList :: [FEST.Context] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ FEST.Context
                   FEST.$fShowContext1) -}
26f5e4b54fa99ca7a57f4aee7bdfba7e
  $fShowContext_$cshowsPrec ::
    GHC.Types.Int -> FEST.Context -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: FEST.Context w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { FEST.Context ww3 ->
                 FEST.$w$cshowsPrec2 ww1 ww3 w2 } }) -}
67e6e11757dadf3eaf7800b8c0224c87
  $fShowContextualAssertation ::
    GHC.Show.Show FEST.ContextualAssertation
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.ContextualAssertation
                  FEST.$fShowContextualAssertation_$cshowsPrec
                  FEST.$fShowContextualAssertation_$cshow
                  FEST.$fShowContextualAssertation_$cshowList -}
67e6e11757dadf3eaf7800b8c0224c87
  $fShowContextualAssertation_$cshow ::
    FEST.ContextualAssertation -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(1*U,1*U),1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: FEST.ContextualAssertation ->
                 FEST.$fShowContextualAssertation_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
67e6e11757dadf3eaf7800b8c0224c87
  $fShowContextualAssertation_$cshowList ::
    [FEST.ContextualAssertation] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ FEST.ContextualAssertation
                   FEST.$fShowContext2) -}
67e6e11757dadf3eaf7800b8c0224c87
  $fShowContextualAssertation_$cshowsPrec ::
    GHC.Types.Int -> FEST.ContextualAssertation -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U(1*U,1*U),1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: FEST.ContextualAssertation
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { FEST.ContextualAssertation ww3 ww4 ->
                 FEST.$w$cshowsPrec3 ww1 ww3 ww4 w2 } }) -}
8dd4ff25e2dfbe4b107d5a6803b228dd
  $fShowDeclaration :: GHC.Show.Show FEST.Declaration
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.Declaration
                  FEST.$fShowDeclaration_$cshowsPrec
                  FEST.$fShowDeclaration_$cshow
                  FEST.$fShowDeclaration_$cshowList -}
8dd4ff25e2dfbe4b107d5a6803b228dd
  $fShowDeclaration1 :: FEST.Declaration -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: FEST.Declaration w1 :: GHC.Base.String ->
                 FEST.$w$cshowsPrec7 0 w w1) -}
8dd4ff25e2dfbe4b107d5a6803b228dd
  $fShowDeclaration_$cshow :: FEST.Declaration -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: FEST.Declaration ->
                 FEST.$fShowDeclaration_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
8dd4ff25e2dfbe4b107d5a6803b228dd
  $fShowDeclaration_$cshowList ::
    [FEST.Declaration] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ FEST.Declaration
                   FEST.$fShowDeclaration1) -}
8dd4ff25e2dfbe4b107d5a6803b228dd
  $fShowDeclaration_$cshowsPrec ::
    GHC.Types.Int -> FEST.Declaration -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: FEST.Declaration
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 FEST.$w$cshowsPrec7 ww1 w1 w2 }) -}
74bca47b1885d5da8e96bb94992f5fe9
  $fShowExpression :: GHC.Show.Show FEST.Expression
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.Expression
                  FEST.$fShowExpression_$cshowsPrec
                  FEST.$fShowExpression_$cshow
                  FEST.$fShowExpression_$cshowList -}
74bca47b1885d5da8e96bb94992f5fe9
  $fShowExpression1 :: FEST.Expression -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: FEST.Expression -> FEST.$w$cshowsPrec1 0 w) -}
74bca47b1885d5da8e96bb94992f5fe9
  $fShowExpression_$cshow :: FEST.Expression -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: FEST.Expression ->
                 FEST.$fShowExpression_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
74bca47b1885d5da8e96bb94992f5fe9
  $fShowExpression_$cshowList :: [FEST.Expression] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ FEST.Expression
                   FEST.$fShowExpression1) -}
74bca47b1885d5da8e96bb94992f5fe9
  $fShowExpression_$cshowsPrec ::
    GHC.Types.Int -> FEST.Expression -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: FEST.Expression ->
                 case w of ww { GHC.Types.I# ww1 -> FEST.$w$cshowsPrec1 ww1 w1 }) -}
d40fbcff0c41141af2a3b3390c55f81b
  $fShowLiteral :: GHC.Show.Show FEST.Literal
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.Literal
                  FEST.$fShowLiteral_$cshowsPrec
                  FEST.$fShowLiteral_$cshow
                  FEST.$fShowLiteral_$cshowList -}
d40fbcff0c41141af2a3b3390c55f81b
  $fShowLiteral1 :: FEST.Literal -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: FEST.Literal -> FEST.$w$cshowsPrec8 0 w) -}
cd70a1bf908552e28ccbf6b7be9a616d
  $fShowLiteral2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FracLiteral "#) -}
98148202f68e2c33a15f745c08e44ef9
  $fShowLiteral3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "IntLiteral "#) -}
847ed38e29796b7f3cbb4a05b418a047
  $fShowLiteral4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CharLiteral "#) -}
b84c1a2f35757599fadc8f7f6d5b5e47
  $fShowLiteral5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "StringLiteral "#) -}
751ab93f8138088b3fb1b44423e01c46
  $fShowLiteral6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   GHC.Show.shows14
                   (GHC.Types.[] @ GHC.Types.Char)) -}
ef761f5394dceb59d5afaf07ef334a9d
  $fShowLiteral7 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows15
                   (GHC.Types.[] @ GHC.Types.Char)) -}
72c18151a91dbbbe46d65fa2e7bf048d
  $fShowLiteral8 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows6
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d40fbcff0c41141af2a3b3390c55f81b
  $fShowLiteral_$cshow :: FEST.Literal -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ x :: FEST.Literal ->
                 case x of wild {
                   FEST.StringLiteral b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        FEST.$fShowLiteral5
                        (GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.shows6
                           (GHC.Show.showLitString b1 FEST.$fShowLiteral8))
                   FEST.CharLiteral b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        FEST.$fShowLiteral4
                        (case b1 of ww { GHC.Types.C# ww1 ->
                         case ww1 of ds {
                           DEFAULT
                           -> GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.shows15
                                (GHC.Show.$wshowLitChar ds FEST.$fShowLiteral7)
                           '\'' -> FEST.$fShowLiteral6 } })
                   FEST.IntLiteral b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        FEST.$fShowLiteral3
                        (case GHC.Show.$w$cshowsPrec1
                                11
                                b1
                                (GHC.Types.[] @ GHC.Types.Char) of ww2 { (#,#) ww3 ww4 ->
                         GHC.Types.: @ GHC.Types.Char ww3 ww4 })
                   FEST.FracLiteral b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        FEST.$fShowLiteral2
                        (case b1 of ww { GHC.Types.D# ww1 ->
                         GHC.Float.$w$sshowSignedFloat
                           GHC.Float.$fShowDouble_$sshowFloat
                           FEST.$fShowCase3
                           ww1
                           (GHC.Types.[] @ GHC.Types.Char) }) }) -}
d40fbcff0c41141af2a3b3390c55f81b
  $fShowLiteral_$cshowList :: [FEST.Literal] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ FEST.Literal
                   FEST.$fShowLiteral1) -}
d40fbcff0c41141af2a3b3390c55f81b
  $fShowLiteral_$cshowsPrec ::
    GHC.Types.Int -> FEST.Literal -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: FEST.Literal ->
                 case w of ww { GHC.Types.I# ww1 -> FEST.$w$cshowsPrec8 ww1 w1 }) -}
96976895518626ffceefcc1709859e83
  $fShowNameSpace :: GHC.Show.Show FEST.NameSpace
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.NameSpace
                  FEST.$fShowNameSpace_$cshowsPrec
                  FEST.$fShowNameSpace_$cshow
                  FEST.$fShowNameSpace_$cshowList -}
96976895518626ffceefcc1709859e83
  $fShowNameSpace_$cshow :: FEST.NameSpace -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: FEST.NameSpace ->
                 FEST.$fShowNameSpace_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
96976895518626ffceefcc1709859e83
  $fShowNameSpace_$cshowList :: [FEST.NameSpace] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ FEST.NameSpace
                   FEST.$w$cshowsPrec6) -}
96976895518626ffceefcc1709859e83
  $fShowNameSpace_$cshowsPrec ::
    GHC.Types.Int -> FEST.NameSpace -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int w1 :: FEST.NameSpace w2 :: GHC.Base.String ->
                 FEST.$w$cshowsPrec6 w1 w2) -}
b7ed2cd8bbc299368d4e67f077b04597
  $fShowPattern :: GHC.Show.Show FEST.Pattern
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.Pattern
                  FEST.$fShowCase_$cshowsPrec
                  FEST.$fShowPattern_$cshow
                  FEST.$fShowPattern_$cshowList -}
b7ed2cd8bbc299368d4e67f077b04597
  $fShowPattern1 :: FEST.Pattern -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (FEST.$fShowCase_$cshowsPrec FEST.$fShowPattern2) -}
ef29212162dcd4be5c64e94002ddda98
  $fShowPattern2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
290ab21523d92548e27130f56872ceff
  $fShowPatternClause :: GHC.Show.Show FEST.PatternClause
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.PatternClause
                  FEST.$fShowPatternClause_$cshowsPrec
                  FEST.$fShowPatternClause_$cshow
                  FEST.$fShowPatternClause_$cshowList -}
290ab21523d92548e27130f56872ceff
  $fShowPatternClause1 :: FEST.PatternClause -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: FEST.PatternClause ->
                 case w of ww { FEST.PatternClause ww1 ww2 ww3 ->
                 FEST.$w$cshowsPrec9 0 ww1 ww2 ww3 }) -}
13f5782ef6bb1a6c9d60a4cca983be3d
  $fShowPatternClause2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PatternClause "#) -}
290ab21523d92548e27130f56872ceff
  $fShowPatternClause_$cshow :: FEST.PatternClause -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U(U,U),U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: FEST.PatternClause ->
                 FEST.$fShowPatternClause_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
290ab21523d92548e27130f56872ceff
  $fShowPatternClause_$cshowList ::
    [FEST.PatternClause] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ FEST.PatternClause
                   FEST.$fShowPatternClause1) -}
290ab21523d92548e27130f56872ceff
  $fShowPatternClause_$cshowsPrec ::
    GHC.Types.Int -> FEST.PatternClause -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U(U(U,U),U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: FEST.PatternClause ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { FEST.PatternClause ww3 ww4 ww5 ->
                 FEST.$w$cshowsPrec9 ww1 ww3 ww4 ww5 } }) -}
b7ed2cd8bbc299368d4e67f077b04597
  $fShowPattern_$cshow :: FEST.Pattern -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: FEST.Pattern ->
                 FEST.$fShowCase_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
b7ed2cd8bbc299368d4e67f077b04597
  $fShowPattern_$cshowList :: [FEST.Pattern] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ FEST.Pattern
                   FEST.$fShowPattern1) -}
45b1f5883cb2d7385b6a64406417599d
  $fShowTypeExpression :: GHC.Show.Show FEST.TypeExpression
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.TypeExpression
                  FEST.$fShowTypeExpression_$cshowsPrec
                  FEST.$fShowTypeExpression_$cshow
                  FEST.$fShowTypeExpression_$cshowList -}
45b1f5883cb2d7385b6a64406417599d
  $fShowTypeExpression_$cshow ::
    FEST.TypeExpression -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: FEST.TypeExpression ->
                 FEST.$fShowTypeExpression_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
45b1f5883cb2d7385b6a64406417599d
  $fShowTypeExpression_$cshowList ::
    [FEST.TypeExpression] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ FEST.TypeExpression
                   FEST.$fShowContext4) -}
45b1f5883cb2d7385b6a64406417599d
  $fShowTypeExpression_$cshowsPrec ::
    GHC.Types.Int -> FEST.TypeExpression -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: FEST.TypeExpression
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 FEST.$w$cshowsPrec4 ww1 w1 w2 }) -}
a8fd9c0aacb3ce35339ab402888eb354
  $fShowTypeSignature :: GHC.Show.Show FEST.TypeSignature
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.TypeSignature
                  FEST.$fShowTypeSignature_$cshowsPrec
                  FEST.$fShowTypeSignature_$cshow
                  FEST.$fShowTypeSignature_$cshowList -}
a8fd9c0aacb3ce35339ab402888eb354
  $fShowTypeSignature1 :: FEST.TypeSignature -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: FEST.TypeSignature w1 :: GHC.Base.String ->
                 case w of ww { FEST.TypeSignature ww1 ww2 ->
                 FEST.$w$cshowsPrec10 0 ww1 ww2 w1 }) -}
1752f34583567ba869f98d25937b79e2
  $fShowTypeSignature2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TypeSignature "#) -}
a8fd9c0aacb3ce35339ab402888eb354
  $fShowTypeSignature_$cshow :: FEST.TypeSignature -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(1*U),1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: FEST.TypeSignature ->
                 FEST.$fShowTypeSignature_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
a8fd9c0aacb3ce35339ab402888eb354
  $fShowTypeSignature_$cshowList ::
    [FEST.TypeSignature] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ FEST.TypeSignature
                   FEST.$fShowTypeSignature1) -}
a8fd9c0aacb3ce35339ab402888eb354
  $fShowTypeSignature_$cshowsPrec ::
    GHC.Types.Int -> FEST.TypeSignature -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U(1*U),1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: FEST.TypeSignature
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { FEST.TypeSignature ww3 ww4 ->
                 FEST.$w$cshowsPrec10 ww1 ww3 ww4 w2 } }) -}
ec0e04f3757b9b2248122cc5aca779ad
  $fShowVarName :: GHC.Show.Show FEST.VarName
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ FEST.VarName
                  FEST.$fShowVarName_$cshowsPrec
                  FEST.$fShowVarName_$cshow
                  FEST.$fShowVarName_$cshowList -}
ec0e04f3757b9b2248122cc5aca779ad
  $fShowVarName1 :: FEST.VarName -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: FEST.VarName w1 :: GHC.Base.String ->
                 case w of ww { FEST.VarName ww1 ww2 ->
                 FEST.$w$cshowsPrec5 0 ww1 ww2 w1 }) -}
ec0e04f3757b9b2248122cc5aca779ad
  $fShowVarName_$cshow :: FEST.VarName -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: FEST.VarName ->
                 FEST.$fShowVarName_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
ec0e04f3757b9b2248122cc5aca779ad
  $fShowVarName_$cshowList :: [FEST.VarName] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ FEST.VarName
                   FEST.$fShowVarName1) -}
ec0e04f3757b9b2248122cc5aca779ad
  $fShowVarName_$cshowsPrec ::
    GHC.Types.Int -> FEST.VarName -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U,1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: FEST.VarName w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { FEST.VarName ww3 ww4 ->
                 FEST.$w$cshowsPrec5 ww1 ww3 ww4 w2 } }) -}
74bca47b1885d5da8e96bb94992f5fe9
  $w$c/= ::
    FEST.Pattern
    -> FEST.Expression
    -> FEST.Pattern
    -> FEST.Expression
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: FEST.Pattern
                   ww1 :: FEST.Expression
                   ww2 :: FEST.Pattern
                   ww3 :: FEST.Expression ->
                 case FEST.$fEqCase_$c==1 ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case FEST.$fEqCase_$c== ww1 ww3 of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } }) -}
74bca47b1885d5da8e96bb94992f5fe9
  $w$c== ::
    FEST.Pattern
    -> FEST.Expression
    -> FEST.Pattern
    -> FEST.Expression
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: FEST.Pattern
                   ww1 :: FEST.Expression
                   ww2 :: FEST.Pattern
                   ww3 :: FEST.Expression ->
                 case FEST.$fEqCase_$c==1 ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> FEST.$fEqCase_$c== ww1 ww3 }) -}
3f9806e5e6f9bddc0492a5daad071ebe
  $w$c==1 ::
    FEST.NameSpace
    -> GHC.Base.String
    -> [FEST.TypeExpression]
    -> FEST.NameSpace
    -> GHC.Base.String
    -> [FEST.TypeExpression]
    -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><S,1*U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ ww :: FEST.NameSpace
                   ww1 :: GHC.Base.String
                   ww2 :: [FEST.TypeExpression]
                   ww3 :: FEST.NameSpace
                   ww4 :: GHC.Base.String
                   ww5 :: [FEST.TypeExpression] ->
                 case FEST.$w$c==2 ww ww1 ww3 ww4 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> GHC.Classes.$fEq[]_$c==
                        @ FEST.TypeExpression
                        FEST.$fEqTypeExpression
                        ww2
                        ww5 }) -}
78fe8ec83632a7e128cf673f69743517
  $w$c==2 ::
    FEST.NameSpace
    -> GHC.Base.String
    -> FEST.NameSpace
    -> GHC.Base.String
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: FEST.NameSpace
                   ww1 :: GHC.Base.String
                   ww2 :: FEST.NameSpace
                   ww3 :: GHC.Base.String ->
                 case ww of wild {
                   FEST.TypeCons
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.False
                        FEST.TypeCons -> GHC.Base.eqString ww1 ww3 }
                   FEST.ValueCons
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.False
                        FEST.ValueCons -> GHC.Base.eqString ww1 ww3 }
                   FEST.Value
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.False
                        FEST.Value -> GHC.Base.eqString ww1 ww3 }
                   FEST.Type
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.False
                        FEST.Type -> GHC.Base.eqString ww1 ww3 } }) -}
442df837e15d6f165b9244e2f5fabf1d
  $w$c==3 ::
    FEST.NameSpace
    -> GHC.Base.String
    -> [FEST.Pattern]
    -> FEST.Expression
    -> FEST.NameSpace
    -> GHC.Base.String
    -> [FEST.Pattern]
    -> FEST.Expression
    -> GHC.Types.Bool
  {- Arity: 8, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><L,1*U><S,1*U><L,1*U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ ww :: FEST.NameSpace
                   ww1 :: GHC.Base.String
                   ww2 :: [FEST.Pattern]
                   ww3 :: FEST.Expression
                   ww4 :: FEST.NameSpace
                   ww5 :: GHC.Base.String
                   ww6 :: [FEST.Pattern]
                   ww7 :: FEST.Expression ->
                 case FEST.$w$c==2 ww ww1 ww4 ww5 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case GHC.Classes.$fEq[]_$c==
                             @ FEST.Pattern
                             FEST.$fEqPattern
                             ww2
                             ww6 of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True -> FEST.$fEqCase_$c== ww3 ww7 } }) -}
91c704e4e6838e086820a02bee10d565
  $w$c==4 ::
    [FEST.ContextualAssertation]
    -> FEST.TypeExpression
    -> [FEST.ContextualAssertation]
    -> FEST.TypeExpression
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: [FEST.ContextualAssertation]
                   ww1 :: FEST.TypeExpression
                   ww2 :: [FEST.ContextualAssertation]
                   ww3 :: FEST.TypeExpression ->
                 case GHC.Classes.$fEq[]_$c==
                        @ FEST.ContextualAssertation
                        FEST.$fEqContextualAssertation
                        ww
                        ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> FEST.$fEqTypeExpression_$c== ww1 ww3 }) -}
63be2f8c56e5a57934d15658424372bd
  $w$cpretty :: FEST.Pattern -> FEST.Expression -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: FEST.Pattern ww1 :: FEST.Expression ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (FEST.$fPrettyCase_$cpretty2 ww)
                   (GHC.CString.unpackAppendCString#
                      " -> "#
                      (FEST.$fPrettyCase_$cpretty1 ww1))) -}
4be39effe965fef1b7ac10e8206f44c3
  $w$cpretty1 :: [FEST.ContextualAssertation] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ ww :: [FEST.ContextualAssertation] ->
                 case ww of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : ipv ipv1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        (GHC.CString.unpackAppendCString#
                           "("#
                           (GHC.Base.++
                              @ GHC.Types.Char
                              (FEST.$fPrettyContext3 wild)
                              FEST.$fPrettyContext2))
                        FEST.$fPrettyContext1 }) -}
f37a5ca7f2201bf1e6d6f6cc40f53c43
  $w$cpretty2 ::
    GHC.Base.String -> [FEST.TypeExpression] -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Base.String ww1 :: [FEST.TypeExpression] ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   ww
                   (GHC.CString.unpackAppendCString#
                      " "#
                      (case FEST.$fPrettyContext_go ww1 of wild {
                         [] -> GHC.Types.[] @ GHC.Types.Char : ds1 xs -> xs }))) -}
691b538d56994d04a843c540dfaa23e6
  $w$cpretty3 ::
    GHC.Base.String
    -> [FEST.Pattern] -> FEST.Expression -> GHC.Base.String
  {- Arity: 3, Strictness: <S,1*U><L,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Base.String
                   ww1 :: [FEST.Pattern]
                   ww2 :: FEST.Expression ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   ww
                   (GHC.CString.unpackAppendCString#
                      " "#
                      (let {
                         a :: [GHC.Types.Char]
                         = GHC.CString.unpackAppendCString#
                             " = "#
                             (FEST.$fPrettyCase_$cpretty1 ww2)
                       } in
                       case FEST.$fPrettyPatternClause_go ww1 of wild {
                         []
                         -> GHC.Base.++ @ GHC.Types.Char (GHC.Types.[] @ GHC.Types.Char) a
                         : ds1 xs -> GHC.Base.++ @ GHC.Types.Char xs a }))) -}
1d7f1ad6f758fd3ead434adcaf027318
  $w$cpretty4 ::
    [FEST.ContextualAssertation]
    -> FEST.TypeExpression -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: [FEST.ContextualAssertation]
                   ww1 :: FEST.TypeExpression ->
                 case ww of wild {
                   [] -> FEST.$fPrettyTypeExpression_$cpretty ww1
                   : ipv ipv1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        (GHC.CString.unpackAppendCString#
                           "("#
                           (GHC.Base.++
                              @ GHC.Types.Char
                              (FEST.$fPrettyContext3 wild)
                              FEST.$fPrettyContext2))
                        (GHC.Base.++
                           @ GHC.Types.Char
                           FEST.$fPrettyContext1
                           (FEST.$fPrettyTypeExpression_$cpretty ww1)) }) -}
74bca47b1885d5da8e96bb94992f5fe9
  $w$cshowsPrec ::
    GHC.Prim.Int# -> FEST.Pattern -> FEST.Expression -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U><L,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: FEST.Pattern
                   ww2 :: FEST.Expression ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = FEST.$fShowCase_$cshowsPrec FEST.$fShowCase3 ww1
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = FEST.$w$cshowsPrec1 11 ww2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> \ x :: GHC.Base.String ->
                      GHC.Base.++
                        @ GHC.Types.Char
                        FEST.$fShowCase2
                        (f (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           FEST.$fShowCase2
                           (f (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.showSpace1
                                 (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x))))) }) -}
74bca47b1885d5da8e96bb94992f5fe9
  $w$cshowsPrec1 ::
    GHC.Prim.Int# -> FEST.Expression -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0] -}
f100cd0f2afc59572542db039ebad850
  $w$cshowsPrec10 ::
    GHC.Prim.Int#
    -> FEST.Context
    -> FEST.TypeExpression
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U><L,1*U(1*U)><L,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: FEST.Context
                   ww2 :: FEST.TypeExpression
                   w :: GHC.Base.String ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     case ww1 of ww3 { FEST.Context ww4 ->
                     FEST.$w$cshowsPrec2
                       11
                       ww4
                       (GHC.Types.:
                          @ GHC.Types.Char
                          GHC.Show.showSpace1
                          (FEST.$w$cshowsPrec4 11 ww2 x)) }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++ @ GHC.Types.Char FEST.$fShowTypeSignature2 (g w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           FEST.$fShowTypeSignature2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w))) }) -}
1974a1049df1cc1daa038b96e76df691
  $w$cshowsPrec2 ::
    GHC.Prim.Int#
    -> [FEST.ContextualAssertation]
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: [FEST.ContextualAssertation]
                   w :: GHC.Base.String ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        FEST.$fShowContext10
                        (GHC.Show.showList__
                           @ FEST.ContextualAssertation
                           FEST.$fShowContext2
                           ww1
                           w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           FEST.$fShowContext10
                           (GHC.Show.showList__
                              @ FEST.ContextualAssertation
                              FEST.$fShowContext2
                              ww1
                              (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w))) }) -}
8125915bf6da3b474758bf1c4e841dde
  $w$cshowsPrec3 ::
    GHC.Prim.Int#
    -> FEST.VarName
    -> [FEST.TypeExpression]
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U><L,1*U(1*U,1*U)><L,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: FEST.VarName
                   ww2 :: [FEST.TypeExpression]
                   w :: GHC.Base.String ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     case ww1 of ww3 { FEST.VarName ww4 ww5 ->
                     FEST.$w$cshowsPrec5
                       11
                       ww4
                       ww5
                       (GHC.Types.:
                          @ GHC.Types.Char
                          GHC.Show.showSpace1
                          (GHC.Show.showList__
                             @ FEST.TypeExpression
                             FEST.$fShowContext4
                             ww2
                             x)) }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++ @ GHC.Types.Char FEST.$fShowContext3 (g w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           FEST.$fShowContext3
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w))) }) -}
45b1f5883cb2d7385b6a64406417599d
  $w$cshowsPrec4 ::
    GHC.Prim.Int#
    -> FEST.TypeExpression -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0] -}
12d7e1161bcd732beadd5532762eb1e9
  $w$cshowsPrec5 ::
    GHC.Prim.Int#
    -> FEST.NameSpace
    -> GHC.Base.String
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U><L,1*U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: FEST.NameSpace
                   ww2 :: GHC.Base.String
                   w :: GHC.Base.String ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       FEST.$fShowContext9
                       (FEST.$w$cshowsPrec6
                          ww1
                          (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.showSpace1
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.shows6
                                (GHC.Show.showLitString
                                   ww2
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 x)))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p w
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w)) }) -}
96976895518626ffceefcc1709859e83
  $w$cshowsPrec6 ::
    FEST.NameSpace -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: FEST.NameSpace w1 :: GHC.Base.String ->
                 case w of wild {
                   FEST.TypeCons
                   -> GHC.Base.++ @ GHC.Types.Char FEST.$fShowContext8 w1
                   FEST.ValueCons
                   -> GHC.Base.++ @ GHC.Types.Char FEST.$fShowContext7 w1
                   FEST.Value -> GHC.Base.++ @ GHC.Types.Char FEST.$fShowContext6 w1
                   FEST.Type
                   -> GHC.Base.++ @ GHC.Types.Char FEST.$fShowContext5 w1 }) -}
8dd4ff25e2dfbe4b107d5a6803b228dd
  $w$cshowsPrec7 ::
    GHC.Prim.Int#
    -> FEST.Declaration -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0] -}
d40fbcff0c41141af2a3b3390c55f81b
  $w$cshowsPrec8 :: GHC.Prim.Int# -> FEST.Literal -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# w :: FEST.Literal ->
                 case w of wild {
                   FEST.StringLiteral b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> \ x :: GHC.Base.String ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             FEST.$fShowLiteral5
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.shows6
                                (GHC.Show.showLitString
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 x)))
                        GHC.Types.True
                        -> \ x :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                FEST.$fShowLiteral5
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.shows6
                                   (GHC.Show.showLitString
                                      b1
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.shows6
                                         (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x))))) }
                   FEST.CharLiteral b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> \ x :: GHC.Base.String ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             FEST.$fShowLiteral4
                             (case b1 of ww1 { GHC.Types.C# ww2 ->
                              case ww2 of ds {
                                DEFAULT
                                -> GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.shows15
                                     (GHC.Show.$wshowLitChar
                                        ds
                                        (GHC.Types.: @ GHC.Types.Char GHC.Show.shows15 x))
                                '\'' -> GHC.Base.++ @ GHC.Types.Char GHC.Show.shows14 x } })
                        GHC.Types.True
                        -> \ x :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                FEST.$fShowLiteral4
                                (case b1 of ww1 { GHC.Types.C# ww2 ->
                                 case ww2 of ds {
                                   DEFAULT
                                   -> GHC.Types.:
                                        @ GHC.Types.Char
                                        GHC.Show.shows15
                                        (GHC.Show.$wshowLitChar
                                           ds
                                           (GHC.Types.:
                                              @ GHC.Types.Char
                                              GHC.Show.shows15
                                              (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)))
                                   '\''
                                   -> GHC.Base.++
                                        @ GHC.Types.Char
                                        GHC.Show.shows14
                                        (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x) } })) }
                   FEST.IntLiteral b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> \ x :: GHC.Base.String ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             FEST.$fShowLiteral3
                             (case GHC.Show.$w$cshowsPrec1 11 b1 x of ww2 { (#,#) ww3 ww4 ->
                              GHC.Types.: @ GHC.Types.Char ww3 ww4 })
                        GHC.Types.True
                        -> \ x :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                FEST.$fShowLiteral3
                                (case GHC.Show.$w$cshowsPrec1
                                        11
                                        b1
                                        (GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.shows8
                                           x) of ww2 { (#,#) ww3 ww4 ->
                                 GHC.Types.: @ GHC.Types.Char ww3 ww4 })) }
                   FEST.FracLiteral b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = case b1 of ww1 { GHC.Types.D# ww2 ->
                          GHC.Float.$w$sshowSignedFloat
                            GHC.Float.$fShowDouble_$sshowFloat
                            FEST.$fShowCase3
                            ww2 }
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> \ x :: GHC.Base.String ->
                           GHC.Base.++ @ GHC.Types.Char FEST.$fShowLiteral2 (g x)
                        GHC.Types.True
                        -> \ x :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                FEST.$fShowLiteral2
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x))) } }) -}
21efb9bb7cba15174f85de1c08291df0
  $w$cshowsPrec9 ::
    GHC.Prim.Int#
    -> FEST.VarName
    -> [FEST.Pattern]
    -> FEST.Expression
    -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,U><L,U(U,U)><L,U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: FEST.VarName
                   ww2 :: [FEST.Pattern]
                   ww3 :: FEST.Expression ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = FEST.$w$cshowsPrec1 11 ww3
                 } in
                 let {
                   g1 :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x :: GHC.Base.String ->
                     case ww1 of ww4 { FEST.VarName ww5 ww6 ->
                     FEST.$w$cshowsPrec5
                       11
                       ww5
                       ww6
                       (GHC.Types.:
                          @ GHC.Types.Char
                          GHC.Show.showSpace1
                          (GHC.Show.showList__
                             @ FEST.Pattern
                             FEST.$fShowPattern1
                             ww2
                             (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))) }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> \ x :: GHC.Base.String ->
                      GHC.Base.++ @ GHC.Types.Char FEST.$fShowPatternClause2 (g1 x)
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           FEST.$fShowPatternClause2
                           (g1 (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x))) }) -}
74bca47b1885d5da8e96bb94992f5fe9
  data Case = Case FEST.Pattern FEST.Expression
26f5e4b54fa99ca7a57f4aee7bdfba7e
  data Context = Context [FEST.ContextualAssertation]
67e6e11757dadf3eaf7800b8c0224c87
  data ContextualAssertation
    = ContextualAssertation FEST.VarName [FEST.TypeExpression]
8dd4ff25e2dfbe4b107d5a6803b228dd
  data Declaration
    = TypeSynonymDeclaration FEST.VarName
                             [FEST.VarName]
                             FEST.TypeExpression
    | DataTypeDeclaration FEST.Context
                          FEST.VarName
                          [FEST.VarName]
                          [FEST.Declaration]
    | ClassDeclaration FEST.Context
                       FEST.VarName
                       [FEST.VarName]
                       [FEST.Declaration]
    | InstanceDeclaration FEST.Context
                          FEST.VarName
                          [FEST.TypeExpression]
                          [FEST.Declaration]
    | ValueDeclaration [FEST.PatternClause]
    | TypeSignatureDeclaration FEST.VarName FEST.TypeSignature
74bca47b1885d5da8e96bb94992f5fe9
  data Expression
    = LambdaExpression FEST.Pattern FEST.Expression
    | ApplicationExpression FEST.Expression FEST.Expression
    | CaseExpression FEST.Expression [FEST.Case]
    | LiteralExpression FEST.Literal
    | VariableExpression FEST.VarName
    | TypeAnnotatedExpression FEST.Expression FEST.TypeSignature
d40fbcff0c41141af2a3b3390c55f81b
  data Literal
    = StringLiteral GHC.Base.String
    | CharLiteral GHC.Types.Char
    | IntLiteral GHC.Integer.Type.Integer
    | FracLiteral GHC.Types.Double
96976895518626ffceefcc1709859e83
  data NameSpace = TypeCons | ValueCons | Value | Type
    Promotable
b7ed2cd8bbc299368d4e67f077b04597
  data Pattern
    = VarPattern FEST.VarName
    | LiteralPattern FEST.Literal
    | BlackHolePattern
    | ConstructedPattern FEST.VarName [FEST.Pattern]
290ab21523d92548e27130f56872ceff
  data PatternClause
    = PatternClause FEST.VarName [FEST.Pattern] FEST.Expression
0abe3bf62c34c8e690d5609e1361738c
  class Pretty p where
    pretty :: p -> GHC.Base.String
45b1f5883cb2d7385b6a64406417599d
  data TypeExpression
    = ApplicationTypeExpression FEST.TypeExpression FEST.TypeExpression
    | VariableTypeExpression FEST.VarName
a8fd9c0aacb3ce35339ab402888eb354
  data TypeSignature = TypeSignature FEST.Context FEST.TypeExpression
ec0e04f3757b9b2248122cc5aca779ad
  data VarName = VarName FEST.NameSpace GHC.Base.String
4f6c774f27814c7a3b37775d51e4cf4a
  indent :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: GHC.Base.String ->
                 Data.OldList.unlines
                   (GHC.Base.build
                      @ [GHC.Types.Char]
                      (\ @ b1
                         c :: [GHC.Types.Char] -> b1 -> b1[OneShot]
                         n :: b1[OneShot] ->
                       GHC.Base.foldr
                         @ [GHC.Types.Char]
                         @ b1
                         (GHC.Base.mapFB
                            @ [GHC.Types.Char]
                            @ b1
                            @ [GHC.Types.Char]
                            c
                            FEST.indent1)
                         n
                         (Data.OldList.lines x)))) -}
f47a620356b5e0bae4c7bddfa0c88b54
  indent1 :: [GHC.Types.Char] -> [GHC.Types.Char]
  {- Arity: 1,
     Unfolding: (GHC.Base.++ @ GHC.Types.Char FEST.indent2) -}
f41b7463261f59bbbc6182cf19c23a17
  indent2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "  "#) -}
670c5e51cb4da1ab35405e3ffbadedbb
  parenPretty :: FEST.Pretty a => a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*C1(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a $dPretty :: FEST.Pretty a eta :: a ->
                 FEST.parens ($dPretty `cast` (FEST.NTCo:Pretty[0] <a>_N) eta)) -}
1d0b686d9aa1b1a5f71ac5ac177498b7
  parens :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ s :: GHC.Base.String ->
                 GHC.CString.unpackAppendCString#
                   "("#
                   (GHC.Base.++ @ GHC.Types.Char s FEST.$fPrettyContext2)) -}
6a0aa4783990b34d8dcb65fc65f4273f
  prettyLines :: FEST.Pretty a => [a] -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a $dPretty :: FEST.Pretty a eta :: [a] ->
                 Data.OldList.unlines
                   (GHC.Base.build
                      @ [GHC.Types.Char]
                      (\ @ b1
                         c :: [GHC.Types.Char] -> b1 -> b1[OneShot]
                         n :: b1[OneShot] ->
                       GHC.Base.foldr
                         @ a
                         @ b1
                         (GHC.Base.mapFB
                            @ [GHC.Types.Char]
                            @ b1
                            @ a
                            c
                            $dPretty `cast` (FEST.NTCo:Pretty[0] <a>_N))
                         n
                         eta))) -}
b6b728f51f3f9f01bc4e2c2328903357
  prettyWords :: FEST.Pretty a => [a] -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a $dPretty :: FEST.Pretty a eta :: [a] ->
                 letrec {
                   go5 :: [a] -> [GHC.Types.Char] {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [a] ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ GHC.Types.Char
                       : y ys
                       -> GHC.Types.:
                            @ GHC.Types.Char
                            FEST.prettyWords1
                            (GHC.Base.++
                               @ GHC.Types.Char
                               ($dPretty `cast` (FEST.NTCo:Pretty[0] <a>_N) y)
                               (go5 ys)) }
                 } in
                 case go5 eta of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char : ds1 xs -> xs }) -}
7585fdcf273c4a9df99ccde6de5682ec
  prettyWords1 :: GHC.Types.Char
  {- HasNoCafRefs, Unfolding: (GHC.Types.C# ' ') -}
fb0af344055da6ba64dcc574aaf0f1bf
  prettytep :: FEST.TypeExpression -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a :: FEST.TypeExpression ->
                 case a of wild {
                   FEST.ApplicationTypeExpression ipv ipv1
                   -> FEST.parens (FEST.$fPrettyTypeExpression_$cpretty wild)
                   FEST.VariableTypeExpression ds
                   -> FEST.$fPrettyTypeExpression_$cpretty wild }) -}
f4a9d46404ed05a845d2c76363509ca4
  testCase :: FEST.Expression
  {- Strictness: m2,
     Unfolding: (FEST.ApplicationExpression
                   FEST.testCase4
                   FEST.testCase1) -}
b2c78c0f257e9fc63b1a36db73157491
  testCase1 :: FEST.Expression
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (FEST.LiteralExpression FEST.testCase2) -}
e60dd46116f22b35e09f8e2b20d28919
  testCase2 :: FEST.Literal
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (FEST.IntLiteral FEST.testCase3) -}
aae92ed83bbdcc4f3651c172c86a080e
  testCase3 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 5) -}
ab3bc7faf401e87775f0f64e8181ff62
  testCase4 :: FEST.Expression
  {- Strictness: m1,
     Unfolding: (FEST.LambdaExpression FEST.testCase8 FEST.testCase5) -}
2e9645b1b5ed40dadbcbb373b1dc5bda
  testCase5 :: FEST.Expression
  {- Strictness: m5,
     Unfolding: (FEST.VariableExpression FEST.testCase6) -}
8e909ebda0078e84dbf4eabc253cac5f
  testCase6 :: FEST.VarName
  {- Strictness: m,
     Unfolding: (FEST.VarName FEST.Value FEST.testCase7) -}
188b3ed83193d55dbc5843a0cf98aea8
  testCase7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "x"#) -}
ebbf49acafe574e83bc54a6f4bf637d4
  testCase8 :: FEST.Pattern
  {- Strictness: m1, Unfolding: (FEST.VarPattern FEST.testCase6) -}
b8c4ffcde4cd9dc3fa4b5708310113fb
  vpretty :: FEST.Expression -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ l :: FEST.Expression ->
                 case l of wild {
                   DEFAULT
                   -> GHC.CString.unpackAppendCString#
                        "("#
                        (GHC.Base.++
                           @ GHC.Types.Char
                           (FEST.$fPrettyCase_$cpretty1 wild)
                           FEST.$fPrettyContext2)
                   FEST.LiteralExpression ds -> FEST.$fPrettyCase_$cpretty1 wild
                   FEST.VariableExpression ds
                   -> FEST.$fPrettyCase_$cpretty1 wild }) -}
instance GHC.Classes.Eq [FEST.Case] = FEST.$fEqCase
instance GHC.Classes.Eq [FEST.Context] = FEST.$fEqContext
instance GHC.Classes.Eq [FEST.ContextualAssertation]
  = FEST.$fEqContextualAssertation
instance GHC.Classes.Eq [FEST.Declaration] = FEST.$fEqDeclaration
instance GHC.Classes.Eq [FEST.Expression] = FEST.$fEqExpression
instance GHC.Classes.Eq [FEST.Literal] = FEST.$fEqLiteral
instance GHC.Classes.Eq [FEST.NameSpace] = FEST.$fEqNameSpace
instance GHC.Classes.Eq [FEST.Pattern] = FEST.$fEqPattern
instance GHC.Classes.Eq [FEST.PatternClause]
  = FEST.$fEqPatternClause
instance GHC.Classes.Eq [FEST.TypeExpression]
  = FEST.$fEqTypeExpression
instance GHC.Classes.Eq [FEST.TypeSignature]
  = FEST.$fEqTypeSignature
instance GHC.Classes.Eq [FEST.VarName] = FEST.$fEqVarName
instance FEST.Pretty [FEST.Case] = FEST.$fPrettyCase
instance FEST.Pretty [FEST.Context] = FEST.$fPrettyContext
instance FEST.Pretty [FEST.ContextualAssertation]
  = FEST.$fPrettyContextualAssertation
instance FEST.Pretty [FEST.Declaration] = FEST.$fPrettyDeclaration
instance FEST.Pretty [GHC.Types.Double] = FEST.$fPrettyDouble
instance FEST.Pretty [FEST.Expression] = FEST.$fPrettyExpression
instance FEST.Pretty [GHC.Integer.Type.Integer]
  = FEST.$fPrettyInteger
instance FEST.Pretty [FEST.Literal] = FEST.$fPrettyLiteral
instance FEST.Pretty [FEST.Pattern] = FEST.$fPrettyPattern
instance FEST.Pretty [FEST.PatternClause]
  = FEST.$fPrettyPatternClause
instance FEST.Pretty [FEST.TypeExpression]
  = FEST.$fPrettyTypeExpression
instance FEST.Pretty [FEST.TypeSignature]
  = FEST.$fPrettyTypeSignature
instance FEST.Pretty [FEST.VarName] = FEST.$fPrettyVarName
instance GHC.Show.Show [FEST.Case] = FEST.$fShowCase
instance GHC.Show.Show [FEST.Context] = FEST.$fShowContext
instance GHC.Show.Show [FEST.ContextualAssertation]
  = FEST.$fShowContextualAssertation
instance GHC.Show.Show [FEST.Declaration] = FEST.$fShowDeclaration
instance GHC.Show.Show [FEST.Expression] = FEST.$fShowExpression
instance GHC.Show.Show [FEST.Literal] = FEST.$fShowLiteral
instance GHC.Show.Show [FEST.NameSpace] = FEST.$fShowNameSpace
instance GHC.Show.Show [FEST.Pattern] = FEST.$fShowPattern
instance GHC.Show.Show [FEST.PatternClause]
  = FEST.$fShowPatternClause
instance GHC.Show.Show [FEST.TypeExpression]
  = FEST.$fShowTypeExpression
instance GHC.Show.Show [FEST.TypeSignature]
  = FEST.$fShowTypeSignature
instance GHC.Show.Show [FEST.VarName] = FEST.$fShowVarName
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

